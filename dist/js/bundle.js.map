{"version":3,"sources":["webpack:///webpack/bootstrap 2f6ca112c79479a58a88","webpack:///./src/js/index.js","webpack:///./src/js/Scanner-1.js","webpack:///./src/js/utils/qr-scanner.js","webpack:///./src/style/index.scss?a856"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC7DA;AACA,gD;;;;;;ACDA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO;AACzE,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,mBAAmB,GAAG;AAC5E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yB;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT,oBAAoB;AACpB,SAAS,IAAI;;AAEb;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,uE;;;;;;AC9OA,yC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2f6ca112c79479a58a88","let scanner = new ( require('./Scanner-1') );\n// let scanner = new ( require('./Scanner-2') );\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/index.js\n// module id = 1\n// module chunks = 0","const QrScanner = require('./utils/qr-scanner.js');\nconst CLEAR_QR_CODE_DATA = 2500; //ms\n\nclass Scanner {\n    constructor() {\n        if( !checkSupported() ) return alert('User Media API not supported.');\n\n        this.video = document.querySelector('#camera');\n        this.container_video = document.querySelector('.container_video');\n        this.startScan = document.querySelector('.start');\n        this.stopScan = document.querySelector('.stop');\n        this.qrCodeElement = document.querySelector('.qrCode');\n        this.lamp = document.querySelector('.button_lamp');\n        this.track;\n        this.qrScanner;\n        this.isLamp = false;\n\n        this.enabledCamera = this.enabledCamera.bind( this );\n        this.disabledCamera = this.disabledCamera.bind( this );\n        this.onOffLamp = this.onOffLamp.bind( this );\n        this.isEsc = this.isEsc.bind( this );\n        this.startScan.addEventListener('click', this.enabledCamera );\n        this.stopScan.addEventListener('click', this.disabledCamera );\n        this.lamp.addEventListener('click', this.onOffLamp );\n    }\n\n    disabledCamera() {\n        this.container_video.classList.remove('active');\n        this.track.stop();\n        this.qrScanner.stop();\n        document.removeEventListener('keyup', this.isEsc );\n        setTimeout(() => {\n            this.qrCodeElement.innerHTML = '';\n        },CLEAR_QR_CODE_DATA);\n    };\n\n    enabledCamera() {\n        this.container_video.classList.add('active');\n        navigator.mediaDevices.getUserMedia({\n            video: {\n                facingMode: 'environment',\n            }\n        })\n        .then( stream => {\n            this.video.srcObject = stream;\n            this.track = stream.getVideoTracks()[0];\n\n            this.video.addEventListener('loadedmetadata', () => {\n                document.addEventListener('keyup', this.isEsc );\n                if ( this.qrScanner ) this.qrScanner.start();\n                else{\n                    this.qrScanner = new QrScanner(this.video, result => {\n                        this.disabledCamera();\n                        console.log('qr code:', result);\n                        this.qrCodeElement.innerHTML = `result: ${result}`;\n                    });\n                }\n            });\n        })\n        .catch(error => {\n            console.error('getUserMedia() failed: ', error );\n            alert( 'No cameras found.' );\n            this.container_video.classList.remove('active');\n        });\n    }\n\n    onOffLamp() {\n        let settings = this.track.getCapabilities();\n        if( settings.hasOwnProperty('torch') ) {\n            this.isLamp = !this.isLamp;\n            this.track.applyConstraints({ advanced: [{torch: this.isLamp}] });\n        }\n    }\n\n    isEsc( event ) {\n        if( event.keyCode === 27 ) this.disabledCamera();\n    }\n};\n\nfunction checkSupported () {\n    if (!navigator.getUserMedia && !navigator.webkitGetUserMedia &&\n        !navigator.mozGetUserMedia && !navigator.msGetUserMedia) {\n        return false;\n    }\n\n    return true;\n};\n\nmodule.exports = Scanner;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/Scanner-1.js\n// module id = 2\n// module chunks = 0","class QrScanner {\n    constructor(video, onDecode, canvasSize = QrScanner.DEFAULT_CANVAS_SIZE) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._active = false;\n\n        this.$canvas.width = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect = {\n            x: 0,\n            y: 0,\n            width: canvasSize,\n            height: canvasSize\n        };\n\n        this.$video.addEventListener('canplay', () => this._updateSourceRect());\n        this.$video.addEventListener('play', () => {\n            this._active = true;\n            this._updateSourceRect();\n            this._scanFrame();\n        }, false);\n        this._qrWorker = new Worker(QrScanner.WORKER_PATH);\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n\n        if (this.$video.paused || this.$video.ended ) return false;\n        requestAnimationFrame(() => {\n            if( !this._active ) return;\n            QrScanner.scanImage(this.$video, this._sourceRect, this._qrWorker, this.$canvas, true)\n                .then(this._onDecode, error => {\n                    if (error !== 'QR code not found.') {\n                        console.error(error);\n                    }\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    start() {\n        if (this._active) {\n            return Promise.resolve();\n        }\n        this._active = true;\n        clearTimeout(this._offTimeout);\n        let facingMode = 'environment';\n        return this._getCameraStream('environment', true)\n            .catch(() => {\n                // we (probably) don't have an environment camera\n                facingMode = 'user';\n                return this._getCameraStream(); // throws if we can't access the camera\n            })\n            .then(stream => {\n                this.$video.srcObject = stream;\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        if (!this._active) {\n            return;\n        }\n        this._active = false;\n        this.$video.pause();\n        this._offTimeout = setTimeout(() => {\n            this.$video.srcObject.getTracks()[0].stop();\n            this.$video.srcObject = null;\n        }, 3000);\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    setGrayscaleWeights(red, green, blue) {\n        this._qrWorker.postMessage({\n            type: 'grayscaleWeights',\n            data: { red, green, blue }\n        });\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect=null, worker=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutSourceRect=false) {\n        const promise = new Promise((resolve, reject) => {\n\n            worker = worker || new Worker(QrScanner.WORKER_PATH);\n            let timeout, onMessage, onError;\n            onMessage = event => {\n                if (event.data.type !== 'qrResult') {\n                    return;\n                }\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                if (event.data.data !== null) {\n                    resolve(event.data.data);\n                } else {\n                    reject('QR code not found.');\n                }\n            };\n            onError = () => {\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                reject('Worker error.');\n            };\n            worker.addEventListener('message', onMessage);\n            worker.addEventListener('error', onError);\n            timeout = setTimeout(onError, 3000);\n            QrScanner._loadImage(imageOrFileOrUrl).then(image => {\n                const imageData = QrScanner._getImageData(image, sourceRect, canvas, fixedCanvasSize);\n                worker.postMessage({\n                    type: 'decode',\n                    data: imageData\n                }, [imageData.data.buffer]);\n            }).catch(reject);\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            return promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, worker, canvas, fixedCanvasSize));\n        } else {\n            return promise;\n        }\n    }\n\n    /* async */\n    static _getImageData(image, sourceRect=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const sourceRectX = sourceRect && sourceRect.x? sourceRect.x : 0;\n        const sourceRectY = sourceRect && sourceRect.y? sourceRect.y : 0;\n        const sourceRectWidth = sourceRect && sourceRect.width? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrUrl) {\n        if (imageOrFileOrUrl instanceof HTMLCanvasElement || imageOrFileOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrUrl).then(() => imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof File || imageOrFileOrUrl instanceof URL\n            ||  typeof(imageOrFileOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrUrl instanceof File) {\n                image.src = URL.createObjectURL(imageOrFileOrUrl);\n            } else {\n                image.src = imageOrFileOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrUrl instanceof File) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.WORKER_PATH = './workers/qr-scanner-worker.js';\n\nmodule.exports = QrScanner;\n/** @preserve @asset(/libraries/qr-scanner/qr-scanner-worker.min.js) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/qr-scanner.js\n// module id = 3\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/style/index.scss\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}